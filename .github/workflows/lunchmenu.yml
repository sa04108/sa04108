name: Send Lunch Menu to Slack

on:
  schedule:
    - cron: '0 1 * * *'  # ë§¤ì¼ ì˜¤ì „ 10ì‹œ (í•œêµ­ì‹œê°„)
  workflow_dispatch:      # ìˆ˜ë™ ì‹¤í–‰

jobs:
  send-menu:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    
    - name: Install dependencies
      run: |
        npm init -y
        npm install puppeteer
    
    - name: Get menu image and send to Slack
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        LUNCH_MENU_URL: "https://pf.kakao.com/_xbnuZn/posts"
      run: |
        node -e "
        const puppeteer = require('puppeteer');
        const https = require('https');
        
        (async () => {
          console.log('ğŸš€ ì ì‹¬ ë©”ë‰´ ì›¹ì‚¬ì´íŠ¸ í¬ë¡¤ë§ ì‹œì‘...');
          
          const browser = await puppeteer.launch({
            headless: true,
            args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage']
          });
          
          const page = await browser.newPage();
          await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');
          
          try {
            // í˜ì´ì§€ ë¡œë“œ
            console.log('ğŸ“„ í˜ì´ì§€ ë¡œë“œ ì¤‘...');
            await page.goto('$LUNCH_MENU_URL', { 
              waitUntil: 'networkidle0', 
              timeout: 30000 
            });
            
            // í˜ì´ì§€ ë‚´ìš© ëŒ€ê¸°
            await page.waitForTimeout(5000);
            
            // 'ì‹ë‹¨' í…ìŠ¤íŠ¸ ë‹¤ìŒ ì´ë¯¸ì§€ ì°¾ê¸°
            console.log('ğŸ” ì‹ë‹¨ ê´€ë ¨ ì´ë¯¸ì§€ ê²€ìƒ‰ ì¤‘...');
            
            const imageUrl = await page.evaluate(() => {
              // ëª¨ë“  í…ìŠ¤íŠ¸ ë…¸ë“œì—ì„œ 'ì‹ë‹¨' í¬í•¨í•˜ëŠ” ìš”ì†Œ ì°¾ê¸°
              function findTextNode(node, text) {
                if (node.nodeType === Node.TEXT_NODE) {
                  if (node.textContent.includes(text)) {
                    return node.parentElement;
                  }
                } else {
                  for (let child of node.childNodes) {
                    const result = findTextNode(child, text);
                    if (result) return result;
                  }
                }
                return null;
              }
              
              // 'ì‹ë‹¨' í…ìŠ¤íŠ¸ê°€ ìˆëŠ” ìš”ì†Œ ì°¾ê¸°
              const textElement = findTextNode(document.body, 'ì‹ë‹¨');
              if (!textElement) {
                console.log('ì‹ë‹¨ í…ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return null;
              }
              
              // í•´ë‹¹ ìš”ì†Œì˜ ë¶€ëª¨ë‚˜ í˜•ì œ ìš”ì†Œì—ì„œ ì´ë¯¸ì§€ ì°¾ê¸°
              let currentElement = textElement;
              for (let i = 0; i < 5; i++) { // ìµœëŒ€ 5ë‹¨ê³„ê¹Œì§€ ìƒìœ„ë¡œ ì˜¬ë¼ê°€ë©° ê²€ìƒ‰
                if (currentElement) {
                  // í˜„ì¬ ìš”ì†Œì™€ í•˜ìœ„ ìš”ì†Œì—ì„œ ì´ë¯¸ì§€ ì°¾ê¸°
                  const images = currentElement.querySelectorAll('img');
                  if (images.length > 0) {
                    for (let img of images) {
                      if (img.src && (img.src.includes('.jpg') || img.src.includes('.png') || img.src.includes('.jpeg'))) {
                        return img.src;
                      }
                    }
                  }
                  
                  // ë‹¤ìŒ í˜•ì œ ìš”ì†Œì—ì„œ ì´ë¯¸ì§€ ì°¾ê¸°
                  let nextElement = currentElement.nextElementSibling;
                  while (nextElement) {
                    const siblingImages = nextElement.querySelectorAll('img');
                    if (siblingImages.length > 0) {
                      for (let img of siblingImages) {
                        if (img.src && (img.src.includes('.jpg') || img.src.includes('.png') || img.src.includes('.jpeg'))) {
                          return img.src;
                        }
                      }
                    }
                    nextElement = nextElement.nextElementSibling;
                  }
                  
                  currentElement = currentElement.parentElement;
                }
              }
              
              return null;
            });
            
            await browser.close();
            
            if (imageUrl) {
              console.log('âœ… ì´ë¯¸ì§€ ë°œê²¬:', imageUrl);
              
              // Slackìœ¼ë¡œ ì „ì†¡
              console.log('ğŸ“¨ Slackìœ¼ë¡œ ì „ì†¡ ì¤‘...');
              
              const slackData = {
                channel: '#lunch', // ì±„ë„ëª… ë³€ê²½ ê°€ëŠ¥
                text: 'ğŸ½ï¸ ì´ë²ˆ ì£¼ ì‹ë‹¨ ë©”ë‰´!',
                attachments: [{
                  color: 'good',
                  title: 'ì¹´ì¹´ì˜¤ ì±„ë„ ì‹ë‹¨ ì •ë³´',
                  image_url: imageUrl,
                  footer: 'ì¹´ì¹´ì˜¤ ì±„ë„ì—ì„œ ìë™ ìˆ˜ì§‘',
                  ts: Math.floor(Date.now() / 1000)
                }]
              };
              
              const postData = JSON.stringify(slackData);
              
              const options = {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Content-Length': Buffer.byteLength(postData)
                }
              };
              
              const req = https.request('$SLACK_WEBHOOK_URL', options, (res) => {
                console.log('Slack ì‘ë‹µ ìƒíƒœ:', res.statusCode);
                if (res.statusCode === 200) {
                  console.log('ğŸ‰ Slack ì „ì†¡ ì„±ê³µ!');
                } else {
                  console.log('âŒ Slack ì „ì†¡ ì‹¤íŒ¨');
                }
              });
              
              req.on('error', (e) => {
                console.error('âŒ ìš”ì²­ ì˜¤ë¥˜:', e.message);
                process.exit(1);
              });
              
              req.write(postData);
              req.end();
              
            } else {
              console.log('âŒ ì‹ë‹¨ ê´€ë ¨ ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
              process.exit(1);
            }
            
          } catch (error) {
            console.error('âŒ ì˜¤ë¥˜ ë°œìƒ:', error);
            await browser.close();
            process.exit(1);
          }
        })();
        "
